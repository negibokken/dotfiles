# language
export LANG=en_US.UTF-8
export LC_ALL=en_US.UTF-8

# bin
export PATH=$PATH:$HOME/.bin
export PATH=$PATH:./btools

# rbenv
export PATH=$HOME/.rbenv/shims:$PATH

# golang
export PATH=$PATH:/usr/local/opt/go/libexec/bin
export GOROOT=/usr/local/opt/go/libexec
export GOPATH=$HOME/go:$HOME/.ghq/
export PATH=$PATH:$HOME/go/bin:$PATH:$GOROOT/bin:$HOME/.go/bin
export MYGO=$GOPATH/src/github.com/negibokken

# pyenv
export PYENV_ROOT="$HOME/.pyenv"
export PATH="$PYENV_ROOT/shims:$PATH"

# nodebrew
export PATH=$PATH:./node_modules/.bin
export PATH=$HOME/.nodebrew/current/bin:$PATH
export PATH=$PATH:$HOME/.config/yarn/global/node_modules/.bin

# sbin
export PATH="/usr/local/sbin:$PATH"

# Android
export PATH="/Users/bokken/Library/Android/sdk/platform-tools:$PATH"

# vscode plantuml
export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_112.jdk/Contents/Home
export PLANTUML_JAR=/usr/local/Cellar/plantuml/8048/libexec/plantuml.jar
export GRAPHVIZ_DOT=/usr/local/Cellar/graphviz/2.40.1/bin/dot

# Chromium tools
# export PATH=$PATH:/usr/local/bin/depot_tools
export PATH=$PATH:$(ghq root)/chromium.googlesource.com/chromium/tools/depot_tools

# For flex & bison
#export PATH="/usr/local/opt/flex/bin:$PATH"
export PATH="/usr/local/opt/bison/bin:$PATH"
export PATH="/usr/local/bin:$PATH"

# Hub
function git(){
  # Refuse if push target branch is important branches
  if [[ "$1" = push  && "$2" = origin && ( "$3" = develop || "$3" = master || "$3" = main) ]]; then
    echo "\e[31;3mpush to develop, master or main is invalid"
    return
  fi
  hub "$@"
}

# history
HISTFILE=~/.zsh_history
HISTSIZE=100000
SAVEHIST=100000

# colorize
autoload -Uz colors
colors

autoload -Uz compinit
compinit

# complement file name
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'

# auto pushd
DIRSTACKSIZE=100
setopt AUTO_PUSHD
autoload -Uz compinit && compinit
zstyle ':completion:*' menu select
zstyle ':completion:*:cd:*' ignore-parents parent pwd
zstyle ':completion:*:descriptions' format '%BCompletion%b %U%d%u'

# prompt
PROMPT=$'%{\e[30;48;5;235m%}%{\e[38;5;044m%}[%n@%m]%{\e[0m%}%{\e[30;48;5;235m\e[38;5;015m%} %~ %{${reset_color}%}(%*) \n\$'

# word cursor movement
bindkey '^f' forward-word
bindkey '^b' backward-word

# word definition
autoload -Uz select-word-style
select-word-style default
zstyle ':zle:*' word-chars " /=;@:{},|"
zstyle ':zle:*' word-style unspecified

# vcs prompt
autoload -Uz vcs_info
autoload -Uz add-zsh-hook
setopt prompt_subst
zstyle ':vcs_info:*' enable git
zstyle ':vcs_info:*' disable bzr svn hg
zstyle ':vcs_info:*' formats '%F{cyan}(%s)-[%b]%f'
zstyle ':vcs_info:*' actionformats '%F{red}(%s)-[%b|%a]%f'

function _update_vcs_info_msg() {
  LANG=en_US.UTF-8 vcs_info
  RPROMPT="${vcs_info_msg_0_}"
}
add-zsh-hook precmd _update_vcs_info_msg

# Options
## print_eight_bit
setopt print_eight_bit

## comment
setopt interactive_comments

## cd if specfied only directory
setopt auto_cd

## share history among zsh process
# setopt share_history

## delete same command history
setopt hist_ignore_all_dups

## expand wild card
setopt extended_glob

## delete redundant spaces
setopt hist_reduce_blanks

# 補完の選択を楽にする
zstyle ':completion:*' menu select

## complte using history
autoload -Uz history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^p" history-beginning-search-backward-end
bindkey "^n" history-beginning-search-forward-end

## syntax highlight
source $HOME/dotfiles/zshconf/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh

# ls color setting
export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;91:bd=44;33:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
export LSCOLORS=gxfxcxdxbxegedabagacag
autoload -U colors ; colors ; zstyle ':completion:*' list-colors "${(s.:.)LS_COLORS}"

# aliases
if [ "$(uname)" = 'Darwin' ]; then
  alias ls="ls -G"
elif [ "$(expr substr $(uname -s) 1 5)" = "Linux" ]; then
  alias ls="ls --color"
fi
alias l="ls -lt"
alias la="ls -lta"

alias vi="vim"
alias vio="vim -O"
alias vic="vim -O *.(cc|h|sh)"
alias vip="vim -O *.(py|sh)"

alias grep="grep --color"
alias egrep="egrep --color"
alias rm="rm -rf"

alias cp="cp -i"

alias mkdir="mkdir -p"

alias sudo="sudo "
alias gcp="gcloud"
alias dcku="docker-compose up"
alias dckd="docker-compose down"
alias kube="kubectl"
alias k="kubectl"
alias codegrep='find . -path ./.git -prune -o -path ./log -prune -o -type f -print0 | xargs -0 grep -n -E $1'

alias python="python3"
alias pip="pip3"
alias v="vim"
alias g="git"
alias gstat="git log --since=\"$(date +'%Y-%m-%d')T00:00:00+09:00\" --shortstat --oneline | grep 'changed' | awk '{ s += \$4+\$6} END {print s}'"
alias alp="docker run -it --rm alpine /bin/sh"

alias hb="hub browse"
alias atcoder="cd $(ghq root)/github.com/negibokken/sandbox/atcoder"
alias leetcode="cd $(ghq root)/github.com/negibokken/sandbox/leetcode"

# reload shell quickly
alias x="exec $SHELL -l"

## global alias
alias -g L="| less"
alias -g G="| grep"
alias -g X="| xargs"
alias -g H="| head"
# alias -g T="| tee \"/var/log/sh-$(date +'%y-%m-%d_%H-%m-%d.log').log\""
alias -g T="| tee -a \"/tmp/sh-$(date +'%y-%m-%d.log')\""
alias dw="docker run -v $(pwd):/work -w /work -it ubuntu /bin/bash"
alias '..'='cd ..'
alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'

# Application alias
alias 0xED="open -a 0xED"

# tmux
tmux has-session >/dev/null 2>&1 && if [ -z "${TMUX}" ]; then
  echo '% tmux list-sessions'
  tmux list-sessions
  echo '% tmux list-windows -a'
  tmux list-windows -a
fi
if [[ ! $TMUX ]] ; then
  tmux new-session
fi

# make temp directory
mkdev () {
  if [ ! -n "$1" ]; then
    echo "Usage: mkdev dir-name"
  return
  fi
  local dirName=$1
  local rootDir=$(ghq root)
  local githubUser="github.com/$(git config user.name)"
  if [[ dirName = */* ]]; then
    githubUser = "github.com/negibokken"
  fi
  local devPath="${rootDir}/${githubUser}/${dirName}"
  if [ -e $devPath ]; then
    echo "The directory '$1' is already exists"
    return 1
  fi
  mkdir -p ${devPath}
  cd ${devPath}
  touch README.md
  echo "# $1" >> README.md
  git init
  git add README.md && git commit -m "Initial commit"
}

mktemp () {
  if [ ! -n "$1" ] ; then
    echo "Usage: mktemp dir-name"
    return
  fi
  local dirName=$1
  local rootDir="$HOME/temp"
  local devPath="${rootDir}/${dirName}"
  mkdir -p ${devPath}
  cd ${devPath}
}

mkcd () {
  if [ ! -n "$1" ] ; then
    echo "Usage: mkcd dir-name"
    return
  fi
  if [ -e "$1" ] ; then
    echo "Directory already exists"
    return
  fi
  local dirName=$1
  mkdir -p ${dirName}
  cd ${dirName}
}

gat () {
  git add .
  git cm -m "Add $(basename $(cd .. && pwd)) $(basename $(pwd))"
  git push origin master
}

mkcode () {
  e="F"
  if [ -n "$1" ]; then
    e=$1
  fi
  for i in {A..$e}; do cppdev question$i comp; done
}

###############################
# peco
###############################
function peco-select-history() {
  BUFFER=$(\history -n -r 1 | peco --query "$LBUFFER")
  CURSOR=$#BUFFER
  zle clear-screen
}
zle -N peco-select-history
bindkey '^r' peco-select-history

# search a destination from cdr list
function peco-get-destination-from-cdr() {
  cdr -l | \
  sed -e 's/^[[:digit:]]*[[:blank:]]*//' | \
  peco --query "$LBUFFER"
}

function peco-cdr() {
  local destination="$(peco-get-destination-from-cdr)"
  if [ -n "$destination" ]; then
    BUFFER="cd $destination"
    zle accept-line
  else
    zle reset-prompt
  fi
}
zle -N peco-cdr
bindkey '^x' peco-cdr

function gb() {
  local branch=$(git branch | peco | sed -e 's/[ *]//g')
  if [ "$branch" = "" ]; then
    return
  fi
  echo $branch
  git checkout $branch
}

## peco
alias pro='cd ~/Project/$(ls ~/Project | peco)'
alias temp='cd ~/temp/$(ls ~/temp | peco)'
alias cb='git checkout `git branch |
  peco |
  sed -e "s/\* //g" |
  awk "{print \$1}"`'

function ghq-peco() {
  dir=$(ghq list -p | peco)
  if [ "$dir" = "" ]; then
    echo "\e[31mdirectory not specified"
    return
  fi
  cd $dir
}
alias gp='ghq-peco'

## kill using peco
function peco-pkill() {
  for pid in `ps aux | peco | awk '{ print $2 }'`
  do
    kill $pid
    echo "Killed ${pid}"
  done
}
alias pk="peco-pkill"

function delete-merged-branches() {
  git branch --merged|egrep -v '\*|develop|master|main'|xargs git branch -d
}


## print 256 colors for configuring terminal
function printColors() {
  for c in {000..255}; do echo -n "\e[38;5;${c}m $c" ; [ $(($c%16)) -eq 15 ] && echo;done;echo
}

function cecho() {
  message=$1
  c=$2
  cntl=""
  case $c in
    "black")
      cntl="\e[30m" ;;
    "red")
      cntl="\e[31m" ;;
    "green")
      cntl="\e[32m" ;;
    "yellow")
      cntl="\e[33m" ;;
    "blue")
      cntl="\e[34m" ;;
    "magenta")
      cntl="\e[35m" ;;
    "cyan")
      cntl="\e[36m" ;;
    "white")
      cntl="\e[37m" ;;
    *)
      "" ;;
  esac
  echo "$cntl$message"
}

# The next line updates PATH for the Google Cloud SDK.
if [ -f '/Users/bokken/google-cloud-sdk/path.zsh.inc' ]; then source '/Users/bokken/google-cloud-sdk/path.zsh.inc'; fi
# The next line enables shell command completion for gcloud.
if [ -f '/Users/bokken/google-cloud-sdk/completion.zsh.inc' ]; then source '/Users/bokken/google-cloud-sdk/completion.zsh.inc'; fi

#candidates
export FZF_CTRL_T_COMMAND='rg --files --hidden --follow --glob "!.git/*"'
export FZF_CTRL_T_OPTS='--preview "bat  --color=always --style=header,grid --line-range :100 {}"'

# include local .zshrc
source ~/.zshrc.local

